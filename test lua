-- local ffi = require('ffi')
-- ffi.cdef[[
--     void* __stdcall URLDownloadToFileA(void* LPUNKNOWN, const char* LPCSTR, const char* LPCSTR2, int a, int LPBINDSTATUSCALLBACK);        
--     void* __stdcall ShellExecuteA(void* hwnd, const char* op, const char* file, const char* params, const char* dir, int show_cmd);
-- ]]

-- local urlmon = ffi.load "UrlMon"
-- local wininet = ffi.load "WinInet"
-- local gdi = ffi.load "Gdi32"

-- function download(from, to)
--     wininet.DeleteUrlCacheEntryA(from)
--     urlmon.URLDownloadToFileA(nil, from, to, 0,0)
-- end;


os.execute('explorer https://discord.gg/YwfW63mVqK')

local local_user = globals.get_username()

local tbl = {
    prefix = 'Azur Free | ',
    '[Info]',
    'Current version [2.1] stable',
    'Update [09.01]',
    '- some fixes',
    endl = ' ',
  }

for k, v in pairs(tbl) do
    if k == 'endl' then
      client.log(v)
    elseif k ~= 'prefix' then
      client.log(tbl.prefix .. v)
    end
end
print('Welcome back ' .. local_user .. ' !')

-- script

-- helpers
local ffi = require("ffi")
ffi.cdef[[
  typedef int BOOL;
  typedef long LONG;
  typedef struct{LONG x, y;}POINT, *LPPOINT;
  typedef uintptr_t (__thiscall* GetClientEntity_4242425_t)(void*, int);
  BOOL GetCursorPos(LPPOINT);
  short GetAsyncKeyState(int);
  void* GetProcAddress(void* hModule, const char* lpProcName);
  void* GetModuleHandleA(const char* lpModuleName);

  typedef struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
  } color_struct_t;
  typedef void (*console_color_print)(const color_struct_t&, const char*, ...);

  typedef struct
  {
    float x;
    float y;
    float z;
  } Vector_t;
 
  typedef struct c_animstate
  {
    char        pad0[0x60]; // 0x00
    void*       pEntity; // 0x60
    void*       pActiveWeapon; // 0x64
    void*       pLastActiveWeapon; // 0x68
    float        flLastUpdateTime; // 0x6C
    int            iLastUpdateFrame; // 0x70
    float        flLastUpdateIncrement; // 0x74
    float        flEyeYaw; // 0x78
    float        flEyePitch; // 0x7C
    float        flGoalFeetYaw; // 0x80
    float        flLastFeetYaw; // 0x84
    float        flMoveYaw; // 0x88
    float        flLastMoveYaw; // 0x8C // changes when moving/jumping/hitting ground
    float        flLeanAmount; // 0x90
    char        pad1[0x4]; // 0x94
    float        flFeetCycle; // 0x98 0 to 1
    float        flMoveWeight; // 0x9C 0 to 1
    float        flMoveWeightSmoothed; // 0xA0
    float        flDuckAmount; // 0xA4
    float        flHitGroundCycle; // 0xA8
    float        flRecrouchWeight; // 0xAC
    Vector_t    vecOrigin; // 0xB0
    Vector_t    vecLastOrigin;// 0xBC
    Vector_t    vecVelocity; // 0xC8
    Vector_t    vecVelocityNormalized; // 0xD4
    Vector_t    vecVelocityNormalizedNonZero; // 0xE0
    float        flVelocityLenght2D; // 0xEC
    float        flJumpFallVelocity; // 0xF0
    float        flSpeedNormalized; // 0xF4 // clamped velocity from 0 to 1
    float        flRunningSpeed; // 0xF8
    float        flDuckingSpeed; // 0xFC
    float        flDurationMoving; // 0x100
    float        flDurationStill; // 0x104
    bool        bOnGround; // 0x108
    bool        bHitGroundAnimation; // 0x109
    char        pad2[0x2]; // 0x10A
    float        flNextLowerBodyYawUpdateTime; // 0x10C
    float        flDurationInAir; // 0x110
    float        flLeftGroundHeight; // 0x114
    float        flHitGroundWeight; // 0x118 // from 0 to 1, is 1 when standing
    float        flWalkToRunTransition; // 0x11C // from 0 to 1, doesnt change when walking or crouching, only running
    char        pad3[0x4]; // 0x120
    float        flAffectedFraction; // 0x124 // affected while jumping and running, or when just jumping, 0 to 1
    char        pad4[0x208]; // 0x128
    float        flMinBodyYaw; // 0x330
    float        flMaxBodyYaw; // 0x334
    float        flMinPitch; //0x338
    float        flMaxPitch; // 0x33C
    float m_flFeetSpeedForwardsOrSideWays;
    int            iAnimsetVersion; // 0x340
  } CCSGOPlayerAnimationState_534535_t;

  struct animation_layer_t
  {
    bool m_bClientBlend; // 0x0000
    float m_flBlendIn; // 0x0004
    void * m_pStudioHdr; // 0x0008
    int m_nDispatchSequence; // 0x000C
    int m_nDispatchSequence_2; // 0x0010
    uint32_t m_nOrder; // 0x0014
    uint32_t m_nSequence; // 0x0018
    float m_flPrevCycle; // 0x001C
    float m_flWeight; // 0x0020
    float m_flWeightDeltaRate; // 0x0024
    float m_flPlaybackRate; // 0x0028
    float m_flCycle; // 0x002C
    void * m_pOwner; // 0x0030
    char pad_0038 [4]; // 0x0034
  };
]]

local ffi_helpers = {
  color_print_fn = ffi.cast("console_color_print", ffi.C.GetProcAddress(ffi.C.GetModuleHandleA("tier0.dll"), "?ConColorMsg@@YAXABVColor@@PBDZZ")),
  color_print = function(self, text, color)
  local col = ffi.new("color_struct_t")

  col.r = color:r()
  col.g = color:g()
  col.b = color:b()
  col.a = color:a()

  self.color_print_fn(col, text)
  end
}

local entity_list_ptr = ffi.cast("void***", utils.create_interface("client.dll", "VClientEntityList003"))
local get_client_entity_fn = ffi.cast("GetClientEntity_4242425_t", entity_list_ptr[0][3])

local ffi_helpers = {
  ffi_setup = function(self)
    self.g_VGuiSurface = ffi.cast(ffi.typeof("void***"), utils.create_interface("vguimatsurface.dll", "VGUI_Surface031"))
    self.DrawSetColor = ffi.cast(ffi.typeof("void(__thiscall*)(void*, int, int, int, int)"), self.g_VGuiSurface[0][15])
    self.DrawFilledRectFade = ffi.cast(ffi.typeof("void(__thiscall*)(void*, int, int, int, int, unsigned int, unsigned int, bool)"), self.g_VGuiSurface[0][123])
  end,
  get_entity_address = function(ent_index)
    local addr = get_client_entity_fn(entity_list_ptr, ent_index)
    return addr
  end,
  color_print_fn = ffi.cast("console_color_print", ffi.C.GetProcAddress(ffi.C.GetModuleHandleA("tier0.dll"), "?ConColorMsg@@YAXABVColor@@PBDZZ")),

  color_print = function(self, text, color) local col = ffi.new("color_struct_t") col.r = color:r() col.g = color:g() col.b = color:b() col.a = color:a() self.color_print_fn(col, text) end,
};

function GetAnimationState(entity) local state = ffi.cast('struct c_animstate**', ffi_helpers.get_entity_address(entity:get_index()) + 0x9960)[0] return state end
function GetAnimLayers(entity, layer) local layers = ffi.cast("struct animation_layer_t**", ffi_helpers.get_entity_address(entity:get_index()) + 0x2990)[0][layer]; return layers end


local cheathelpers = {
  iskeyactive = function(keycode) return ffi.C.GetAsyncKeyState(keycode) ~= 0 end,
  getcursorpos = function() local cursor_pos = ffi.new("POINT[1]"); if not ffi.C.GetCursorPos(cursor_pos) then error("Couldn't get cursor position!", 2) end; return vector.new(cursor_pos[0].x, cursor_pos[0].y, 0) end,
  string = {
    split = function(string, separator)
      local result = {};
      for match in (string..separator):gmatch("(.-)"..separator) do
        table.insert(result, match);
      end
      return result;
    end,
  }
}

local function coloredPrint(color, text)
  ffi_helpers.color_print(ffi_helpers, text, color)
end

ffi_helpers:ffi_setup();

ffi.cdef[[typedef int(__fastcall* clantag_t)(const char*, const char*);]]
local fn_change_clantag = utils.find_signature("engine.dll", "53 56 57 8B DA 8B F9 FF 15")
local set_clantag = ffi.cast("clantag_t", fn_change_clantag)

local function get_closest_player(exceptions)
  -- * check if connected to server and in game
  if not engine.is_connected() or not engine.is_in_game() then return end

  -- * exceptions sector create
  if exceptions == nil then exceptions = {} end
  exceptions.distance = exceptions.distance or 999999.0

  -- * check if local player is alive
  local player = entitylist.get_local_player()
  if not player or player:get_health() <= 0.0 then return end
  
  -- * cache
  local closest_player
  local closest_distance = exceptions.distance

  -- * parsing all players
  for index = 0.0, globals.get_maxclients() do
    local entity = entitylist.get_player_by_index(index)
    if not entity or not entity:is_player() then goto skip end

    -- * getting player pointer and check if player is valid
    local _player = entitylist.entity_to_player(entity)
    if not _player or (_player:get_health() <= 0.0 and not exceptions.allow_dead) or (_player:get_dormant() and not exceptions.allow_dormant) then goto skip end
    if _player == player then goto skip end

    -- * teammate check
    if exceptions.teammate ~= nil then
      if not exceptions.teammate and _player:get_team() == player:get_team() then goto skip end
    end

    -- * enemy check
    if exceptions.enemy ~= nil then
      if not exceptions.enemy and _player:get_team() ~= player:get_team() then goto skip end
    end

    -- * weapon check
    if exceptions.weapon ~= nil then
      local weapon = entitylist.get_weapon_by_player(_player)
      if not weapon then return end
      weapon = weapon:get_class_name():lower()
      
      if not (weapon):find (exceptions.weapon:lower()) then goto skip end
    end

    -- * distance check
    local player_origin = player:get_origin()
    local _player_origin = _player:get_origin()

    local distance = player_origin:dist_to(_player_origin)
    if distance <= closest_distance then
      closest_player = _player
      closest_distance = distance
    end

    ::skip::
  end
  return closest_player
end

vector.angle2forward = function(pitch, yaw)
  if pitch ~= nil and yaw ~= nil then
    pitch, yaw = math.rad(pitch), math.rad(yaw);

    return vector.new(math.cos(pitch) * math.cos(yaw), math.cos(pitch) * math.sin(yaw), -math.sin(pitch));
  end
  return vector.new(0, 0, 0)
end

local function get_max_desync_delta(player)
  local animstate = GetAnimationState(player)

  -- local speedfactor = clamp(animstate.m_flFeetSpeedForwardsOrSideWays, 0, 1)
  local max_speed = console.get_int('sv_maxspeed') or 320
  local speedfactor = player:get_velocity():length_2d() / max_speed
  local vector = player:get_origin()
  -- local speedfactor = 0.1
  -- local stop = animstate.m_flStopToFullRunningFraction
  local stop = 1.5
  local avg_speedfactor = (stop * -0.3 - 0.2) * speedfactor + 1

  local duck_amount = player:get_prop_float('CBasePlayer', 'm_flDuckAmount') or 0.0

  if duck_amount > 0 then
    local max_velocity = clamp(animstate.m_flFeetSpeedForwardsOrSideWays, 0, 1)
    local duck_speed = duck_amount * max_velocity

    avg_speedfactor = avg_speedfactor + (duck_speed * (0.5 - avg_speedfactor))
  end

  return 58 * avg_speedfactor
end

function clamp(num, min, max)
  return math.min(math.max(num, min), max)
end

local function normalize_yaw(ang) if ang < -180 then ang = ang + 360 end if ang > 180 then ang = ang - 360 end return ang end

-- lua elements
menu.next_line()

menu.add_slider_int('                           visuals', 0,0)

menu.add_check_box('Binds')

menu.add_check_box('Indicators')

menu.add_color_picker('Indicators color')

menu.add_check_box('Watermark')

menu.add_check_box('View Model')

menu.add_check_box('Custom scope')

menu.add_color_picker('Custom scope color')

menu.add_check_box('Desync Indicator')

menu.add_color_picker('Desync Indicator color')

menu.add_check_box('Damage Indicator')

menu.add_combo_box('Style', {'Static Line', 'Fade', 'Reversed Fade', 'Gradient', 'Animated HUE', 'Chroma', 'Whitee'})

menu.add_slider_int('                        rage & AA', 0,0)

menu.add_check_box('Leg breaker')

menu.add_check_box('Static legs in air')

menu.add_combo_box('Resolver mode', {'None', 'New Method'})

menu.add_slider_int('                              misc', 0,0)

local logs_check = menu.add_check_box('Logs')

menu.add_check_box('Сlantag')

menu.add_check_box('Zeus Fix')

menu.add_slider_int('                          settings', 0,0) -- settings

menu.next_line()

menu.add_color_picker('Style color')

-- menu.add_slider_int('Tick to Flick', 15, 70)

menu.add_slider_float('AutoStrafe Smooth', 2.0, 5.0)

menu.next_line()

menu.add_key_bind('Legit AA')

menu.next_line()

menu.add_key_bind('Force Baim')

menu.next_line()

-- script

local callbacks = {
    on_paint = {
      fonts = {
        Verdana_unsmooth = render.create_font("Verdana", 12, 0, false, false, false),
        Verdanaoutline = render.create_font("Verdana", 12, 0, false, false, true), -- small fonts 12 450
        pixel_fft = render.create_font('Smallest Pixel-7', 10, 0, false, false, true),
        Verdana = render.create_font("Verdana", 12, 0, true, false, false),
        museo_sans_500 = render.create_font('MuseoSansCyrl-500', 13, 0, true, false, false),
        MuseoSansCyrl = render.create_font('MuseoSansCyrl-500', 13, 0, true, false, false),
        MuseoSansCyrl9 = render.create_font('MuseoSansCyrl-900', 15, 0, true, false, false),
        logo_nl = render.create_font('untitled-font-1', 15, 0, true, false, false),
        custom_esp = render.create_font('MuseoSansCyrl-500', 12, 0, true, true, false)
      },
      drag = {
        binds = {
          x = 0.0,
          y = 0.0,
          backup = false,
        },
        active = false,
      },
      cheat = {
        math = {
          lerp = function(start, _end, time, do_extraanim) if (not do_extraanim and math.floor(start) == _end) then return _end end; time = globals.get_frametime() * (time * 175); if time < 0 then time = 0.01 elseif time > 1 then time = 1 end; return (_end - start) * time + start end,
        },
        color = {
          hsv2rgb = function(h, s, v) local r, g, b; local i = math.floor(h * 6); local f = h * 6 - i; local p = v * (1 - s); local q = v * (1 - f * s); local t = v * (1 - (1 - f) * s); i = i % 6; if i == 0 then r, g, b = v, t, p elseif i == 1 then r, g, b = q, v, p elseif i == 2 then r, g, b = p, v, t elseif i == 3 then r, g, b = p, q, v elseif i == 4 then r, g, b = t, p, v elseif i == 5 then r, g, b = v, p, q end return {r = math.floor(r * 255), g = math.floor(g * 255), b = math.floor(b * 255)} end
        },
        alpha = {},
        alphaind = {},
        states = {'[~]', '[holding]', '[toggled]'},
        binds = {
          {text = 'Double Tap', path = 'rage.double_tap_key'},
          {text = 'Hide Shots', path = 'rage.hide_shots_key'},
          {text = 'Damage Override', path = 'rage.force_damage_key'},
          {text = 'Force Baim', path = 'Force Baim'},
          {text = 'Auto Peek', path = 'misc.automatic_peek_key'},
          {text = 'Fake Duck', path = 'anti_aim.fake_duck_key'},
          {text = 'Edge Jump', path = 'misc.edge_jump_key'},
          {text = 'Slow Walk', path = 'misc.slow_walk_key'},
          {text = 'Inverter', path = 'anti_aim.invert_desync_key'},
          {text = 'Legit Anti-Aim', path = 'Legit AA'},
          {text = 'Yaw Forward', path = 'anti_aim.manual_forward_key'},
          {text = 'Yaw Left', path = 'anti_aim.manual_left_key'},
          {text = 'Yaw Right', path = 'anti_aim.manual_right_key'},
          {text = 'Yaw Back', path = 'anti_aim.manual_back_key'},
          {text = 'Aim', path = 'legit.enable_key'},
          {text = 'Auto Wall', path = 'legit.automatic_wall_key'},
          {text = 'Auto Fire', path = 'legit.automatic_fire_key'},
          
        },
        bindinds = {
          {textind = 'DT', pathind = 'rage.double_tap_key'},
          {textind = 'HS', pathind = 'rage.hide_shots_key'},
          {textind = 'AP', pathind = 'misc.automatic_peek_key'},
          {textind = 'FD', pathind = 'anti_aim.fake_duck_key'},
          {textind = 'SW', pathind = 'misc.slow_walk_key'},
          {textind = 'DMG', pathind = 'rage.force_damage_key'},
        },
        get_binds = function(self)
          local active, array = {}, self.binds
          for index, bind in pairs(array) do
            if self.alpha[index] == nil then self.alpha[index] = 0.0 end
            self.alpha[index] = self.math.lerp(self.alpha[index], menu.get_key_bind_state(bind.path) and 1.0 or 0.0, 0.05, true)
            if self.alpha[index] > 0.01 then
              table.insert(active, {text = bind.text, mode = self.states[menu.get_key_bind_mode(bind.path) + 1], alpha = self.alpha[index]})
            end
          end
          return active
        end,
        get_bind_inds = function(self)
          local actives, arrays = {}, self.bindinds
          for indexp, bindind in pairs(arrays) do
            if self.alphaind[indexp] == nil then self.alphaind[indexp] = 0.0 end
            self.alphaind[indexp] = self.math.lerp(self.alphaind[indexp], menu.get_key_bind_state(bindind.pathind) and 1.0 or 0.0, 0.05, true)
            if self.alphaind[indexp] > 0.01 then
              table.insert(actives, {textind = bindind.textind, alphaind = self.alphaind[indexp]})
            end
          end
          return actives
        end,
      },
      gradient_rect = function(self, x, y, w, h, color, color2, horizontal)
        ffi_helpers.DrawSetColor(ffi_helpers.g_VGuiSurface, color:r(), color:g(), color:b(), color:a());
        ffi_helpers.DrawFilledRectFade(ffi_helpers.g_VGuiSurface, x, y, x + w, y + h, 255, 0, horizontal);
        ffi_helpers.DrawSetColor(ffi_helpers.g_VGuiSurface, color2:r(), color2:g(), color2:b(), color2:a());
        ffi_helpers.DrawFilledRectFade(ffi_helpers.g_VGuiSurface, x, y, x + w, y + h, 0, 255, horizontal)
      end,
      adaptive_box = function(self, x, y, w, h, text, alpha)
        local theme = menu.get_int('Style')
        local color = menu.get_color('Style color')
        local rgb = self.cheat.color.hsv2rgb(globals.get_realtime() / 3.0, 1.0, 1.0)
        local rh, gh, bh = math.floor(math.sin(globals.get_realtime() * 4) * 90 + 165), math.floor(math.sin(globals.get_realtime() * 4 + 2) * 90 + 165), math.floor(math.sin(globals.get_realtime() * 4 + 4) * 90 + 165)
        alpha = alpha or 1.0
        local themes = {
          [0] = function() -- static line
            render.draw_rect_filled(x, y, w, 2, color.new(color:r(), color:g(), color:b(), math.floor(255 * alpha)))
          end,
          [1] = function() -- fade
            self:gradient_rect(x, y, w/2, 2, color.new(0, 0, 0, 0), color.new(color:r(), color:g(), color:b(), math.floor(255 * alpha)), true)
            self:gradient_rect(x + w/2, y, w/2, 2, color.new(color:r(), color:g(), color:b(), math.floor(255 * alpha)), color.new(0, 0, 0, 0), true)
          end,
          [2] = function() -- reversed fade
            self:gradient_rect(x, y, w/2, 2, color.new(color:r(), color:g(), color:b(), math.floor(255 * alpha)), color.new(0, 0, 0, 0), true)
            self:gradient_rect(x + w/2, y, w/2, 2, color.new(0, 0, 0, 0), color.new(color:r(), color:g(), color:b(), math.floor(255 * alpha)), true)
          end,
          [3] = function() -- gradient
            self:gradient_rect(x, y, w/2, 2, color.new(0, 255, 255, math.floor(255 * alpha)), color.new(255, 65, 200, math.floor(255 * alpha)), true)
            self:gradient_rect(x + w/2, y, w/2, 2, color.new(255, 65, 200, math.floor(255 * alpha)), color.new(255, 255, 0, math.floor(255 * alpha)), true)
          end,
          [4] = function() -- hue
            self:gradient_rect(x, y, w/2, 2, color.new(rgb.r, rgb.g, rgb.b, math.floor(255 * alpha)), color.new(rgb.g, rgb.b, rgb.r, math.floor(255 * alpha)), true)
            self:gradient_rect(x + w/2, y, w/2, 2, color.new(rgb.g, rgb.b, rgb.r, math.floor(255 * alpha)), color.new(rgb.b, rgb.r, rgb.g, math.floor(255 * alpha)), true)
          end,
          [5] = function() -- chroma
            self:gradient_rect(x, y, w, 2, color.new(rh, gh, bh, math.floor(255 * alpha)), color.new(bh, rh, gh, math.floor(255 * alpha)), true)
          end,
          [6] = function() -- whitee
            self:gradient_rect(x, y, w/2, 2, color.new(rgb.r, rgb.g, rgb.b, math.floor(255 * alpha)), color.new(255, 255, 255, math.floor(255 * alpha)), true)
            self:gradient_rect(x + w/2, y, w/2, 2, color.new(255, 255, 255, math.floor(255 * alpha)), color.new(rgb.b, rgb.r, rgb.g, math.floor(255 * alpha)), true)
          end,
        }
        render.draw_rect_filled(x, y, w, h, color.new(0, 0, 0, math.floor(color:a() * alpha)))
        if themes[theme] ~= nil then
          themes[theme]();
        end
        if text ~= nil then
          render.draw_text_centered(self.fonts.Verdana_unsmooth, x + w/2 + 1.0, y + h/2 + 1.0, color.new(255, 255, 255, math.floor(255 * alpha)), true, true, text)
        end
      end,
      watermark = function(self)
        if not menu.get_bool('Watermark') then return end
        local pos = {
          x = self.screen.x - 5.0,
          y = 5.0,
        }
        local text = {'AzurFree', globals.get_username(), os.date('%X')}
        if engine.is_in_game() then
          table.insert(text, #text, string.format('delay: %sms', globals.get_ping()))
          table.insert(text, #text, string.format('%stick', 1 /globals.get_intervalpertick()))
        end
        text = table.concat(text, ' | ')
  
        local w, h = render.get_text_width(self.fonts.Verdana_unsmooth, text), 19
        pos.x = pos.x - w
  
        if menu.get_int('Style') == 7 then
          self:adaptive_box(pos.x, pos.y, 0, 0, '')
        else
          self:adaptive_box(pos.x - 10.0, pos.y, w + 10.0, h, text)
        end
      end,
      keybinds = function(self)
        if not menu.get_bool('Binds') then return end -- check, if checkbox is enabled
        if menu.get_int('Style') == 7 then return end
        -- if engine.is_connected() then return end
        -- locals
        local pos = {
          x = self.drag.binds.x,
          y = self.drag.binds.y,
        }
        local w, h, maxw = 135, 19, 0.0
        -- automatic resize system
        for _, bind in pairs(self.cheat:get_binds()) do
          if render.get_text_width(self.fonts.Verdana_unsmooth, string.format('%s %s', bind.text, bind.mode)) > maxw then
            maxw = math.floor(render.get_text_width(self.fonts.Verdana_unsmooth, string.format('%s %s', bind.text, bind.mode)) * bind.alpha)
          end
        end
        w = math.max(w, maxw + 25)
        -- rendering all active binds
        for index, bind in pairs(self.cheat:get_binds()) do
          render.draw_text(self.fonts.Verdana_unsmooth, pos.x + 4.0, math.floor(pos.y + h + 2.0 + 15 * bind.alpha * (index - 1)), color.new(255, 255, 255, math.floor(255 * bind.alpha)), bind.text)
          render.draw_text(self.fonts.Verdana_unsmooth, pos.x + w - 5.0 - render.get_text_width(self.fonts.Verdana_unsmooth, bind.mode), pos.y + h + 2.0 + math.floor(15 * bind.alpha * (index - 1)), color.new(255, 255, 255, math.floor(255 * bind.alpha)), bind.mode)
        end
        -- rendering box of our binds (a.k.a. SolusUI)
        if menu.get_int('Style') == 7 then
          self:adaptive_box(pos.x, pos.y, 0, 0, '')
        else
          self:adaptive_box(pos.x, pos.y, w, h, 'keybinds')
        end
        -- drag system
        local cursorpos = cheathelpers.getcursorpos()
        if cursorpos.x > pos.x and cursorpos.x < pos.x + w and cursorpos.y > pos.y and cursorpos.y < pos.y + h then
          if not self.drag.binds.backup and cheathelpers.iskeyactive(0x01) then
            different_x = pos.x - cursorpos.x
            different_y = pos.y - cursorpos.y
            self.drag.binds.backup = true
          end
          -- file.write(savedfile, tostring(self.drag.binds.x).."|"..tostring(self.drag.binds.y) )
        end
        if not cheathelpers.iskeyactive(0x01) then self.drag.binds.backup = false end
        if self.drag.binds.backup then
          self.drag.binds.x = cursorpos.x + different_x
          self.drag.binds.y = cursorpos.y + different_y
        end
      end,
      screen = { x = engine.get_screen_width(), y = engine.get_screen_height() },
      indicators = function(self)
        if not menu.get_bool('Indicators') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        local local_player = entitylist.get_local_player()
        if not local_player then return end
        local color = menu.get_color('Style color')
        local s_color = menu.get_color('Indicators color')
        local s_r, s_g, s_b = s_color:r(), s_color:g(), s_color:b()
        local r, g, b = color:r(), color:g(), color:b()
  
        local tickbase = local_player:get_prop_int('CBasePlayer', 'm_nTickBase')
        local charge = (globals.get_tickcount() - tickbase + 3)
        if menu.get_key_bind_state('rage.double_tap_key') then
          if charge > 0 then
            render.draw_rect_filled(self.screen.x / 2 - 11, (self.screen.y / 2 + 20), 2, 9, color.new(150,255,150))
          else
            render.draw_rect_filled(self.screen.x / 2 - 11, (self.screen.y / 2 + 20), 2, 9, color.new(255,150,150))
          end
        end
        if menu.get_key_bind_state("anti_aim.invert_desync_key") then
          render.draw_text(self.fonts.Verdanaoutline, self.screen.x/2 - 24, self.screen.y/2 + 8, color.new(255,255,255), 'Azur')
          render.draw_text(self.fonts.Verdanaoutline, self.screen.x/2, self.screen.y/2 + 8, color.new(r,g,b), 'Free')
        else
          render.draw_text(self.fonts.Verdanaoutline, self.screen.x/2 - 24, self.screen.y/2 + 8, color.new(r,g,b), 'Azur')
          render.draw_text(self.fonts.Verdanaoutline, self.screen.x/2, self.screen.y/2 + 8, color.new(255,255,255), 'Free')
        end
        -- print(tostring(charge))
        -- rendering all active indicators
        for indexp, bindind in pairs(self.cheat:get_bind_inds()) do
          render.draw_text_centered(self.fonts.Verdanaoutline, self.screen.x/2, self.screen.y/2 + 18 + 10 * bindind.alphaind * (indexp - 1), color.new(s_r, s_g, s_b, math.floor(255 * bindind.alphaind)), true, false, bindind.textind)
        end
      end,
      view_model = function(self)
        if not menu.get_bool('View Model') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        local local_player = entitylist.get_local_player()
        if not local_player then return end
        local scoped = local_player:is_scoped()
        if scoped then console.set_int("fov_cs_debug", 90) else console.set_int("fov_cs_debug", 0) end
      end,
      anim = 0,
      custom_scope = function(self)
        if not menu.get_bool('Custom scope') then console.set_int("cl_drawhud", 1) return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        local local_player = entitylist.get_local_player()
        if not local_player then return end
        local scoped = local_player:is_scoped()
        local color = menu.get_color('Custom scope color')
  
        if scoped then
          console.set_int("cl_drawhud", 0)
          self.anim = self.cheat.math.lerp(self.anim, 1, 0.05, true)
        else
          console.set_int("cl_drawhud", 1)
          self.anim = self.cheat.math.lerp(self.anim, 0, 0.1, true)
        end
  
        self:gradient_rect(self.screen.x / 2 + 10, self.screen.y / 2, math.floor(self.anim * 100), 1, color, color.new(0,0,0,0), 1)
        self:gradient_rect(self.screen.x / 2 - math.floor(self.anim * 100) - 10, self.screen.y / 2, math.floor(self.anim * 100), 1, color.new(0, 0, 0, 0), color, 1)
        self:gradient_rect(self.screen.x / 2, self.screen.y / 2 + 10, 1, math.floor(self.anim * 100), color, color.new(0,0,0,0), 0)
        self:gradient_rect(self.screen.x / 2, self.screen.y / 2 - math.floor(self.anim * 100) - 10, 1, math.floor(self.anim * 100), color.new(0, 0, 0, 0), color, 0)
      end,
      is_alive = function(entity)
        if entity ~= nil then
          return entity:get_health() > 0.0
        end
        return false
      end,
      desync_indicator = function(self)
        if not menu.get_bool('Desync Indicator') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        local col = menu.get_color('Desync Indicator color')
        local r, g, b = col:r(), col:g(), col:b()
  
        local manual_color_left = color.new(0, 0, 0, 80)
        local manual_color_right = color.new(0, 0, 0, 80)
    
        local invert = menu.get_key_bind_state('anti_aim.invert_desync_key')
        local left_manual = menu.get_key_bind_state('anti_aim.manual_left_key')
        local right_manual = menu.get_key_bind_state('anti_aim.manual_right_key')
    
        if left_manual then manual_color_left = color.new(255, 255, 255, 100) end
        if right_manual then manual_color_right = color.new(255, 255, 255, 100) end
    
        render.draw_triangle(self.screen.x/2 + 39 + 15, self.screen.y/2, self.screen.x/2 + 39, self.screen.y/2 + 9, self.screen.x/2 + 39, self.screen.y/2 - 9, manual_color_right) -- right manual
        render.draw_triangle(self.screen.x/2 - 39, self.screen.y/2 + 9, self.screen.x/2 - 39 - 15, self.screen.y/2, self.screen.x/2 - 39, self.screen.y/2 - 9, manual_color_left) -- left manual
    
        render.draw_rect_filled(self.screen.x/2 - 37, self.screen.y/2 - 9, 2, 18, color.new(0, 0, 0, 80)) -- desync deff right rect
        render.draw_rect_filled(self.screen.x/2 + 35, self.screen.y/2 - 9, 2, 18, color.new(0, 0, 0, 80)) -- desync deff left rect
    
        if menu.get_int('anti_aim.desync_type') == 1 or menu.get_int('anti_aim.desync_type') == 3 then
          if invert then
            render.draw_rect_filled(self.screen.x/2 + 35, self.screen.y/2 - 9, 2, 18, col) -- desync left rect
          else
            render.draw_rect_filled(self.screen.x/2 - 37, self.screen.y/2 - 9, 2, 18, col) -- desync right rect
          end
        elseif menu.get_int('anti_aim.desync_type') == 2 then
          if globals.get_tickcount() % 6 < 3 then
            render.draw_rect_filled(self.screen.x/2 + 35, self.screen.y/2 - 9, 2, 18, col) -- desync left rect
          else
            render.draw_rect_filled(self.screen.x/2 - 37, self.screen.y/2 - 9, 2, 18, col) -- desync right rect
          end
        end
      end,
      dmg_indicator = function(self)
        if not menu.get_bool('Damage Indicator') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        local player = entitylist.get_local_player()
        if not player then return end
        local weapon_name = entitylist.get_weapon_by_player(player)
        if not weapon_name then return end
        weapon_name = weapon_name:get_class_id()
  
        for i = 0, 8 do
          if menu.get_key_bind_state('rage.force_damage_key') then
            damage = menu.get_int(string.format('rage.weapon[%s].force_damage_value   ', i))
          else
            damage = menu.get_int(string.format('rage.weapon[%s].minimum_damage   ', i))
          end
  
          local pistols = {239, 241, 245, 246, 258, 269} -- 1 - 7
          local mps = {235, 239, 250, 253, 254, 271}
          local rifles = {1, 232, 240, 244, 249, 265}
  
          local x = self.screen.x/2 + 10
          local y = self.screen.y/2 - 20
  
          for number = 1, 6 do
            if weapon_name == 46 and i == 0 then -- deagle & revolver
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == pistols[number] and i == 1 then -- pistols
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == 242 and i == 2 or weapon_name == 261 and i == 2 then -- auto
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == 267 and i == 3 then -- ssg08
              render.draw_text(self.fonts.Verdana_unsmooth, x , y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == 233 and i == 4 then -- awp
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == rifles[number] and i == 5 then -- rifles
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == mps[number] and i == 6 then -- mps
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == 251 and i == 7 or weapon_name == 256 and i == 7 or weapon_name == 260 and i == 7 or weapon_name == 273 and i == 7 then -- shotguns
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
  
            elseif weapon_name == 247 and i == 8 or weapon_name == 255 and i == 8 then -- miniguns
              render.draw_text(self.fonts.Verdana_unsmooth, x, y, color.new(255,255,255), tostring(damage))
            end
          end
        end
      end,
      animation = {
        " ",
        "A ",
        "Az ",
        "Azu ",
        "Azur ",
        "Azur F ",
        "Azur Fr ",
        "Azur Fre ",
        "Azur Free ",
        "Azur Free 阿 ",
        "Azur Free 祖 ",
        "Azur Free 尔 ",
        "Azur Free 巷",
        "Azur  Free",
        "Azur   Fre",
        "Azur    Fr",
        "Azur     F巷",
        "Azur     阿",
        "Azur ",
        "Azu ",
        "Az ",
        "A ",
        " ",
      },
      old_time = 0,
      clantag_override = false,
      clantag = function(self)
        if not menu.get_bool("Сlantag") then
          if self.clantag_override == false then
            set_clantag(' ', ' ')
            self.clantag_override = true
          end
          return
        end -- check checkbox
        self.clantag_override = false
  
        if not engine.is_connected() or not engine.is_in_game() then return end
  
        local curtime = math.floor(globals.get_curtime() * 1.8)
        local anim = self.animation[curtime % #self.animation+1]
        if old_time ~= curtime and (globals.get_tickcount() % 2) == 1 then
          set_clantag(anim, anim)
          old_time = curtime
        end
      end,
    },
    create_move = {
      screen = { x = engine.get_screen_width(), y = engine.get_screen_height() },
      cache = {
        inv_override = false,
        jump_override = false,
        legitaa_override = false,
        force_baim_override = false,
        yaw_override = false,
        anti_backstab_override = false,
        type_override = false,
        pitch_override = false,
        zeus_override = false,
      },
      static_legs = function(self)
        if not menu.get_bool('Static legs in air') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
  
        local local_player = entitylist.get_local_player()
        if not local_player then return end
  
        local check_air = local_player:get_prop_bool('CBasePlayer', 'm_hGroundEntity')
        if check_air then
          ffi.cast('CCSGOPlayerAnimationState_534535_t**', ffi_helpers.get_entity_address(local_player:get_index()) + 0x9960)[0].flDurationInAir = 99
        end
      end,
      int_c = 0,
      jitter = false,
      e_pressed = 0,
      e_since = 0,
      last_direction = 0,
      leg_breaker = function(self)
        if not menu.get_bool('Leg breaker') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        local local_player = entitylist.get_local_player()
        if not local_player then return end
        ffi.cast('float*', ffi_helpers.get_entity_address(local_player:get_index()) + 0x2778)[0] = 0
        self.int_c = self.int_c + 1
        if self.int_c == 2 then
          self.int_c = 0
        end
        local cur = self.int_c % 2 == 0 and 2 or 1
        if self.int_c == 0 then
          self.jitter = not self.jitter
          if self.jitter then cur = 1 end
        end
        if cheathelpers.iskeyactive(0x45) then
          self.e_pressed = 1
        else
          if self.e_pressed ~= 0 then
            self.e_pressed = self.e_pressed + 1
          end
          if self.e_pressed > 6 then
            self.e_pressed = 0
          end
        end
        self.e_since = (cheathelpers.iskeyactive(0x45) and (self.e_since + 1) or 0)
        local yaw = normalize_yaw(ffi.cast('CCSGOPlayerAnimationState_534535_t**', ffi_helpers.get_entity_address(local_player:get_index()) + 0x9960)[0].flEyeYaw)
        local velocity = local_player:get_velocity()
        local direction = self.last_direction
        if self.int_c == 0 then
          direction = velocity.x * math.cos(yaw / 180 * math.pi) + velocity.y * math.sin(yaw / 180 * math.pi) --i feel like my head just exploded
          self.last_direction = direction
        end
        if direction > 150 and direction < 260 and self.e_since < 4 and self.e_pressed <= 1 then cur = 2 end
        menu.set_int('misc.leg_movement', cur)
      end,
      l_state = false,
  
      legitaa = function(self)
        if not engine.is_connected() or not engine.is_in_game() then return end
        local local_player = entitylist.get_local_player()
        if not local_player then return end
  
        local key = menu.get_key_bind_state('Legit AA')
        local isDefusing = local_player:get_prop_bool('CCSPlayer', 'm_bIsDefusing')
        local isGrabbing = local_player:get_prop_bool('CCSPlayer', 'm_bIsGrabbingHostage')
        if key then
          if isGrabbing or isDefusing then
            console.execute('+use')
          else
            console.execute('-use')
          end
          if not self.cache.legitaa_override then
            self.cache.value_legitaa = {
              default_yaw_aa = menu.get_int('anti_aim.yaw_offset'),
              default_pitch_aa = menu.get_int('anti_aim.pitch'),
            }
            menu.set_int('anti_aim.yaw_offset', 180)
            menu.set_int('anti_aim.pitch', 0)
            self.cache.legitaa_override = true
            self.l_state = true
          end
        else
          if self.cache.legitaa_override then
            if self.l_state then
              console.execute('-use')
              self.l_state = false
            end
            menu.set_int('anti_aim.yaw_offset', self.cache.value_legitaa.default_yaw_aa)
            menu.set_int('anti_aim.pitch', self.cache.value_legitaa.default_pitch_aa)
            self.cache.legitaa_override = false
          end
        end
      end,
      force_baim = function(self)
        -- if not menu.get_key_bind_state('Force Baim') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        if not self.cache.value_force_baim then self.cache.value_force_baim = {} end
        if menu.get_key_bind_state('Force Baim') then
          if not self.cache.force_baim_override then
            for i = 0, 8 do
              self.cache.value_force_baim[i] = menu.get_int(string.format('rage.weapon[%s].body_aim   ', i))
              menu.set_int(string.format('rage.weapon[%s].body_aim', i), 2)
            end
            self.cache.force_baim_override = true
          end
        else
          if self.cache.force_baim_override then
            for i = 0, 8 do
              menu.set_int(string.format('rage.weapon[%s].body_aim', i), self.cache.value_force_baim[i])
            end
            self.cache.force_baim_override = false
          end
        end
      end,
      is_alive = function(entity)
        if entity ~= nil then
          return entity:get_health() > 0.0
        end
        return false
      end,
      zeus_fix = function(self)
        if not menu.get_bool('Zeus Fix') then return end
        if not engine.is_connected() or not engine.is_in_game() then return end
        local player = entitylist.get_local_player()
        if not player then return end
        local weapon_name = entitylist.get_weapon_by_player(player)
        if not weapon_name then return end
        weapon_name = weapon_name:get_class_id()
        if weapon_name == 268 and menu.get_key_bind_state('rage.double_tap_key') or menu.get_key_bind_state('rage.hide_shots_key') then
          if not self.cache.zeus_override then
            self.cache.value_zeus = {
              default_bool = menu.get_bool('anti_aim.enable_fake_lag'),
            }
            menu.set_bool('anti_aim.enable_fake_lag', false)
            self.cache.zeus_override = true
          end
        else
          if self.cache.zeus_override then
            menu.set_bool('anti_aim.enable_fake_lag', self.cache.value_zeus.default_bool)
            self.cache.zeus_override = false
          end
        end
      end,
      brute = {10, -10},
      step_brute = 1,
      get_info_log = function(self, shot_info)
        local log = shot_info.result
        if log == 'Resolver' then
          if self.create_move.step_brute >= #self.create_move.brute then self.create_move.step_brute = 1 end
        end
      end,
      resolver = function(self)
        if menu.get_int('Resolver mode') == 0 then for i = 0, 64 do menu.set_int("player_list.player_settings["..i.."].body_yaw", 0) menu.set_bool("player_list.player_settings["..i.."].force_body_yaw", false) end return end
        if not engine.is_in_game() then return end
        local local_player = entitylist.get_local_player()
        if not local_player then return end
        for i = 0, 64 do
          local entity = entitylist.get_player_by_index(i)
          if not entity then goto next end
          if not entity:is_player() then goto next end
          local player = entitylist.entity_to_player(entity)
          if not player then goto next end
          if player:get_team() == local_player:get_team() then goto next end
          local angles = player:get_angles()
          local yaw = player:get_prop_float('CCSPlayer', 'm_flLowerBodyYawTarget')

          local lby = 0
          local eye_pos = angles.y
          eye_pos, yaw = eye_pos % 58, yaw % 58
          if eye_pos > 0 and yaw < 0 then
            eye_pos = 360 - eye_pos
            lby = yaw + eye_pos
          elseif eye_pos > 0 and yaw > 0 then
            lby = yaw - eye_pos
          end
          lby = math.floor(lby)

          if menu.get_int('Resolver mode') == 1 then
            menu.set_bool(string.format('player_list.player_settings[%s].force_body_yaw', i), true)
            menu.set_int(string.format('player_list.player_settings[%s].body_yaw', i), lby + self.brute[self.step_brute])
            print(tostring('1'))
          end
          ::next::
        end
      end,
    },
    logs = {},
    on_shot = {
      logs_update = function(self)
        logs_check = menu.get_bool('Logs')
          if not engine.is_connected() or not engine.is_in_game() then return end
          local add_y = 0
          for index, log in pairs(self.logs) do
          if globals.get_realtime() - log.time > 4 then
            log.alpha = math.max(log.alpha - globals.get_frametime() * 175 * 0.01, 0)
            if log.alpha < 0.01 then
              table.remove(self.logs, index)
            end
          else
            log.alpha = math.min(log.alpha + globals.get_frametime() * 175 * 0.01, 1)
          end
          render.draw_text(self.on_paint.fonts.Verdana_unsmooth, 5, 5 + add_y, color.new(log.r, log.g, log.b, math.floor(log.alpha * 255)), log.text)
          add_y = add_y + 15 * log.alpha
        end
      end,
      logs = function(self, shot_info)
      if not logs_check then return end
      local results = shot_info.result
      local targetname = engine.get_player_info(shot_info.target_index).name
  
      local entity = entitylist.get_player_by_index(shot_info.target_index)
      local player = entitylist.entity_to_player(entity)
      if not player then return end
  
      local speed = player:get_velocity():length_2d()
      local health = player:get_health()
  
  
      local serverdamage = shot_info.server_damage
      local clientdamage = shot_info.client_damage
      local serverhitbox = shot_info.server_hitbox
      local clienthitbox = shot_info.client_hitbox
      local hitchance = shot_info.hitchance
      local backtrack = shot_info.backtrack_ticks
  
      local local_player = entitylist.get_local_player()
      if not local_player then return end
  
      local weapon_name = entitylist.get_weapon_by_player(local_player)
      if not weapon_name then return end
  
      local inaccuracy = weapon.get_inaccuracy(weapon_name)
      weapon_name = weapon_name:get_class_name()
      weapon_name = weapon_name:gsub('CWeapon', '')
      weapon_name = weapon_name:gsub('CK', 'k')
  
      if results == "None" then
        coloredPrint(color.new(69, 94, 207), '> ')
        coloredPrint(color.new(255, 255, 255), 'Fired at [')
        coloredPrint(color.new(69, 94, 207), targetname)
        coloredPrint(color.new(255, 255, 255), '] | [')
        coloredPrint(color.new(255, 255, 255), clienthitbox)
        coloredPrint(color.new(255, 255, 255), '] bt [')
        coloredPrint(color.new(138, 207, 67), tostring(backtrack))
        coloredPrint(color.new(255, 255, 255), '] dmg [')
        coloredPrint(color.new(207, 61, 61), tostring(clientdamage))
        coloredPrint(color.new(255, 255, 255), '] hc [')
        coloredPrint(color.new(156, 114, 196), tostring(hitchance))
        coloredPrint(color.new(255, 255, 255), ']\n')
  
        coloredPrint(color.new(222, 232, 249), '>> ')
        coloredPrint(color.new(255, 255, 255), 'Missed shot due to ')
        coloredPrint(color.new(222, 232, 249), 'uknown\n')
  
        table.insert(self.logs, 1, {
          text = string.format('>> Missed shot due to unknown'),
          r = 222,
          g = 232,
          b = 249,
          alpha = 0,
          time = globals.get_realtime(),
        })
      elseif results == "Spread" and speed > 200 then
        coloredPrint(color.new(69, 94, 207), '> ')
        coloredPrint(color.new(255, 255, 255), 'Fired at [')
        coloredPrint(color.new(69, 94, 207), targetname)
        coloredPrint(color.new(255, 255, 255), '] | [')
        coloredPrint(color.new(255, 255, 255), clienthitbox)
        coloredPrint(color.new(255, 255, 255), '] bt [')
        coloredPrint(color.new(138, 207, 67), tostring(backtrack))
        coloredPrint(color.new(255, 255, 255), '] dmg [')
        coloredPrint(color.new(207, 61, 61), tostring(clientdamage))
        coloredPrint(color.new(255, 255, 255), '] hc [')
        coloredPrint(color.new(156, 114, 196), tostring(hitchance))
        coloredPrint(color.new(255, 255, 255), ']\n')
  
        coloredPrint(color.new(183, 148, 23), '>> ')
        coloredPrint(color.new(255, 255, 255), 'Missed shot due to ')
        coloredPrint(color.new(183, 148, 23), 'prediction error ')
        coloredPrint(color.new(255, 255, 255), '[angle: ')
        coloredPrint(color.new(249, 162, 82), string.format('%.2f', inaccuracy))
        coloredPrint(color.new(255, 255, 255), ']\n')
  
        table.insert(self.logs, 1, {
          text = string.format('>> Missed shot due to prediction error [angle: %s]', string.format('%.2f', inaccuracy)),
          r = 249,
          g = 162,
          b = 82,
          alpha = 0,
          time = globals.get_realtime(),
        })
      elseif results == "Spread" then
        coloredPrint(color.new(69, 94, 207), '> ')
        coloredPrint(color.new(255, 255, 255), 'Fired at [')
        coloredPrint(color.new(69, 94, 207), targetname)
        coloredPrint(color.new(255, 255, 255), '] | [')
        coloredPrint(color.new(255, 255, 255), clienthitbox)
        coloredPrint(color.new(255, 255, 255), '] bt [')
        coloredPrint(color.new(138, 207, 67), tostring(backtrack))
        coloredPrint(color.new(255, 255, 255), '] dmg [')
        coloredPrint(color.new(207, 61, 61), tostring(clientdamage))
        coloredPrint(color.new(255, 255, 255), '] hc [')
        coloredPrint(color.new(156, 114, 196), tostring(hitchance))
        coloredPrint(color.new(255, 255, 255), ']\n')
  
        coloredPrint(color.new(249, 162, 82), '>> ')
        coloredPrint(color.new(255, 255, 255), 'Missed shot due to ')
        coloredPrint(color.new(249, 162, 82), 'spread ')
        coloredPrint(color.new(255, 255, 255), '[angle: ')
        coloredPrint(color.new(249, 162, 82), string.format('%.2f', inaccuracy))
        coloredPrint(color.new(255, 255, 255), ']\n')
  
  
        table.insert(self.logs, 1, {
          text = string.format('>> Missed shot due to spread [angle: %s]', string.format('%.2f', inaccuracy)),
          r = 249,
          g = 248,
          b = 167,
          alpha = 0,
          time = globals.get_realtime(),
        })
      elseif results == "Resolver" then
        coloredPrint(color.new(69, 94, 207), '> ')
        coloredPrint(color.new(255, 255, 255), 'Fired at [')
        coloredPrint(color.new(69, 94, 207), targetname)
        coloredPrint(color.new(255, 255, 255), '] | [')
        coloredPrint(color.new(255, 255, 255), clienthitbox)
        coloredPrint(color.new(255, 255, 255), '] bt [')
        coloredPrint(color.new(138, 207, 67), tostring(backtrack))
        coloredPrint(color.new(255, 255, 255), '] dmg [')
        coloredPrint(color.new(207, 61, 61), tostring(clientdamage))
        coloredPrint(color.new(255, 255, 255), '] hc [')
        coloredPrint(color.new(156, 114, 196), tostring(hitchance))
        coloredPrint(color.new(255, 255, 255), ']\n')
  
        coloredPrint(color.new(130, 156, 35), '>> ')
        coloredPrint(color.new(255, 255, 255), 'Missed shot due to ')
        if menu.get_int('Resolver mode') ~= 0 then
          coloredPrint(color.new(130, 156, 35), 'resolver ')
          coloredPrint(color.new(255, 255, 255), '[')
          coloredPrint(color.new(247, 140, 108), string.format('%s', menu.get_int(string.format('player_list.player_settings[%s].body_yaw   ', shot_info.target_index))))
          coloredPrint(color.new(255, 255, 255), ']\n')
        else
          coloredPrint(color.new(130, 156, 35), 'resolver\n')
        end
  
        -- menu.get_int(string.format('player_list.player_settings[%s].body_yaw   ', shot_info.target_index)))
  
        table.insert(self.logs, 1, {
          text = string.format('>> Missed shot due to resolver'),
          r = 243,
          g = 163,
          b = 163,
          alpha = 0,
          time = globals.get_realtime(),
        })
      elseif results == "Hit" then
        -- coloredPrint(color.new(187, 131, 240), "hitchance") purple)
        coloredPrint(color.new(69, 94, 207), '> ')
        coloredPrint(color.new(255, 255, 255), 'Fired at [')
        coloredPrint(color.new(69, 94, 207), targetname)
        coloredPrint(color.new(255, 255, 255), '] | [')
        coloredPrint(color.new(255, 255, 255), clienthitbox)
        coloredPrint(color.new(255, 255, 255), '] bt [')
        coloredPrint(color.new(138, 207, 67), tostring(backtrack))
        coloredPrint(color.new(255, 255, 255), '] dmg [')
        coloredPrint(color.new(207, 61, 61), tostring(clientdamage))
        coloredPrint(color.new(255, 255, 255), '] hc [')
        coloredPrint(color.new(156, 114, 196), tostring(hitchance))
        coloredPrint(color.new(255, 255, 255), ']\n')
  
        coloredPrint(color.new(92, 234, 92), '>> ')
        coloredPrint(color.new(255, 255, 255), 'Hit ')
        coloredPrint(color.new(69, 94, 207), targetname)
        coloredPrint(color.new(255, 255, 255), ' in the ')
        coloredPrint(color.new(255, 255, 255), clienthitbox)
        coloredPrint(color.new(255, 255, 255), ' for ')
        coloredPrint(color.new(207, 61, 61), tostring(serverdamage))
        coloredPrint(color.new(255, 255, 255), ' hp with ')
        coloredPrint(color.new(255, 255, 255), weapon_name)
        coloredPrint(color.new(255, 255, 255), ' (')
        coloredPrint(color.new(92, 234, 92), tostring(health))
        if menu.get_int('Resolver mode') ~= 0 then
          coloredPrint(color.new(255, 255, 255), ' remaining) angle ')
          coloredPrint(color.new(255, 255, 255), '[')
          coloredPrint(color.new(247, 140, 108), string.format('%s', menu.get_int(string.format('player_list.player_settings[%s].body_yaw   ', shot_info.target_index))))
          coloredPrint(color.new(255, 255, 255), ']\n')
        else
          coloredPrint(color.new(255, 255, 255), ' remaining)\n')
        end
  
        table.insert(self.logs, 1, {
          text = string.format('>> Hit %s in the %s for %s hp with %s (%s remaining)', targetname, serverhitbox, serverdamage, weapon_name, health),
          r = 167,
          g = 249,
          b = 178,
          alpha = 0,
          time = globals.get_realtime(),
        })
      end
    end,
    },
}

  -- callbacks
client.add_callback('on_paint', function() -- on_paint
callbacks.on_paint:watermark()
callbacks.on_paint:keybinds()
callbacks.on_paint:indicators()
callbacks.on_paint:clantag()
callbacks.on_paint:desync_indicator()
callbacks.on_paint:dmg_indicator()
callbacks.on_paint:custom_scope()
callbacks.on_paint:view_model()
callbacks.on_shot.logs_update(callbacks) -- for checkbox
end)

client.add_callback('create_move', function() -- create_move
callbacks.create_move:legitaa()
callbacks.create_move:force_baim()
callbacks.create_move:static_legs()
callbacks.create_move:leg_breaker()
callbacks.create_move:zeus_fix()
callbacks.create_move:resolver()
end)

client.add_callback('on_shot', function(event) -- on_shot
callbacks.on_shot.logs(callbacks, event)
callbacks.create_move.get_info_log(callbacks, event)
end)

client.add_callback('unload', function() -- unload
-- for i = 0, 64 do menu.set_int("player_list.player_settings["..i.."].body_yaw", 0) menu.set_bool("player_list.player_settings["..i.."].force_body_yaw", false) end
set_clantag(' ', ' ') -- for clantag
console.execute('bind e +use') -- for legit aa
end)

-- chams

local better = [[
{ 
    "$additive"					"1"
}
]]

local glow = [[
{ 
    "$additive"					"1" 
    "$envmap"					"models/effects/cube_white" 
    "$envmaptint"				"[1 1 1]" 
    "$envmapfresnel"			"1" 
    "$envmapfresnelminmaxexp" 	"[0 1 2]" 
    "$alpha" 					"1" 
}
]]

local glass = [[
{
    "$basetexture2"             "brick\brickwall031b"
    "$additive"                 "1"
    "$envmap"                   "editor/cube_vertigo"
    "$envmaptint"               "[0 0.5 0.55]"
    "$envmapfresnel"            "1"
    "$envmapfresnelminmaxexp"   "[0.5 0.6 6]"
    "$alpha"                    "1"
}
]]

local wireframe = [[
{
    "$wireframe"   "1"
}
]]

local glow_pulse = [[
{
"$additive"					"1" 
"$envmap"					"models/effects/cube_white" 
"$envmaptint"				"[1 1 1]" 
"$envmapfresnel"			"1" 
"$envmapfresnelminmaxexp" 	"[0 1 2]" 

Proxies
{
    Sine
    {
        "sineperiod"                "1"
        "sinemin"                    "0.2"
        "resultVar"                    "$envmapfresnelminmaxexp[1]"
    }
    }
}
]]

local glow_circuit = [[
{
    "$additive" "1"
    "$envmap" "models/effects/cube_white"
    "$envmaptint" "[1 1 1]"
    "$envmapfresnel" "1"
    "$envmapfresnelminmaxexp" "[0 5 10]"
    "$alpha" "1"
}
]]

local glow_wireframe = [[
{
    "$additive" "1"
    "$envmap" "models/effects/cube_white"
    "$envmaptint" "[1 1 1]"
    "$envmapfresnel" "1"
    "$envmapfresnelminmaxexp" "[0 1 2]"
    "$alpha" "0.5"
    "$wireframe"                "1"
}
]]

local anim_wireframe = [[
{
    "$basetexture" "nature/urban_puddle01a_ssbump"
    "$additive" "1"
    "$selfillum" "1"
    "$nocull" "1"
    "$wireframe" "1"
    "Proxies"
    {
    "TextureScroll"
    {
        "texturescrollvar" "$BasetextureTransform"
        "texturescrollrate" "0.5"
        "texturescrollangle" "90"
    }
    }
}  
]]

local glow_pulse_wireframe = [[
{
    "$additive" "1"
    "$envmap" "models/effects/cube_white"
    "$envmaptint" "[1 1 1]"
    "$envmapfresnel" "1"
    "$envmapfresnelminmaxexp" "[0 1 2]"
    "$alpha" "1"
    "$wireframe"                "1"
    Proxies
    {
    Sine
    {
        "sineperiod"                "1"
        "sinemin"                    "0.2"
        "resultVar"                    "$envmapfresnelminmaxexp[1]"
    }
    }
}
]]

material.create("Regular Better", better, false)
material.create("Flat Better", better, true)
material.create("Glow", glow, false)
material.create("Glass", glass, false)
material.create("Wireframe", wireframe, false)
material.create("Glow Pulse", glow_pulse, false)
material.create("Glow Circuit", glow_circuit, false)
material.create("Glow Wireframe", glow_wireframe, false)
material.create("Animated Wireframe", anim_wireframe, false)
material.create("Glow Pulse Wireframe", glow_pulse_wireframe, false)
